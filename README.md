# Халина Арсения ИТ-7 Лабораторная №5
## Задание 1
## Задача 1
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
особенностями: 
• Имеет числитель: целое число 
• Имеет знаменатель: целое число 
• Дробь может быть создана с указанием числителя и знаменателя  
• Может вернуть строковое представление вида “числитель/знаменатель” 
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
быть отрицательным.  
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя. 

Алгоритм:
Создаём интерфейс, который определяет контракт для получения вещественного значения дроби, а также для установки её числителя и знаменателя. Затем реализуем основной класс «Дробь». В этом классе объявляем приватные поля для целочисленных числителя и знаменателя. В конструкторе обрабатываем входные значения: проверяем, что знаменатель не равен нулю, и если он отрицательный, переносим знак минус в числитель, чтобы знаменатель всегда оставался положительным. Реализуем требуемые методы интерфейса: метод получения вещественного значения выполняем простым делением, а в методах-сеттерах повторяем ту же логику проверки и корректировки знаков. Дополнительно переопределяем метод для строкового представления дроби в формате «числитель/знаменатель» и настраиваем сравнение объектов так, чтобы две дроби считались равными только при полном совпадении их числителей и знаменателей.

Далее разрабатываем класс «ДробьСКэшем», который наследует функциональность от базовой дроби. Расширяем его, добавляя приватное поле для кэширования вычисленного вещественного значения. В методах, изменяющих состояние (установка числителя и знаменателя), вызываем родительские реализации, а затем сбрасываем кэшированное значение, так как после изменения дроби прежний результат становится неактуальным. В методе получения вещественного значения вводим условие: если кэш пуст, вычисляем значение через вызов родительского метода, сохраняем его в поле и возвращаем; если же значение уже закэшировано, сразу возвращаем его, что позволяет избежать повторных вычислений при многократных вызовах.
