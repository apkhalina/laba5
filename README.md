# Халина Арсения ИТ-7 Лабораторная №5
## Задание 1
## Задача 1
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка 
числителя и установка знаменателя. 
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного 
значения. 
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими 
особенностями: 
• Имеет числитель: целое число 
• Имеет знаменатель: целое число 
• Дробь может быть создана с указанием числителя и знаменателя  
• Может вернуть строковое представление вида “числитель/знаменатель” 
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может 
быть отрицательным.  
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби 
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя. 

Алгоритм:
Создаём интерфейс, который определяет контракт для получения вещественного значения дроби, а также для установки её числителя и знаменателя. Затем реализуем основной класс «Дробь». В этом классе объявляем приватные поля для целочисленных числителя и знаменателя. В конструкторе обрабатываем входные значения: проверяем, что знаменатель не равен нулю, и если он отрицательный, переносим знак минус в числитель, чтобы знаменатель всегда оставался положительным. Реализуем требуемые методы интерфейса: метод получения вещественного значения выполняем простым делением, а в методах-сеттерах повторяем ту же логику проверки и корректировки знаков. Дополнительно переопределяем метод для строкового представления дроби в формате «числитель/знаменатель» и настраиваем сравнение объектов так, чтобы две дроби считались равными только при полном совпадении их числителей и знаменателей.

Далее разрабатываем класс «ДробьСКэшем», который наследует функциональность от базовой дроби. Расширяем его, добавляя приватное поле для кэширования вычисленного вещественного значения. В методах, изменяющих состояние (установка числителя и знаменателя), вызываем родительские реализации, а затем сбрасываем кэшированное значение, так как после изменения дроби прежний результат становится неактуальным. В методе получения вещественного значения вводим условие: если кэш пуст, вычисляем значение через вызов родительского метода, сохраняем его в поле и возвращаем; если же значение уже закэшировано, сразу возвращаем его, что позволяет избежать повторных вычислений при многократных вызовах.

<img width="172" height="124" alt="image" src="https://github.com/user-attachments/assets/ced8298e-4158-4840-8215-2b4afeacc843" />

## Задание 2
## Задача 1
Количество мяуканий.  
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. 
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы 
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом 
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим 
количество мяуканий на экран. Кота изменять нельзя. 
 
Если раннее в вашем варианте не было Кота, то создайте  
1. сущность Кот, которая описывается следующим образом: 
• Имеет Имя (строка) 
• Для создания необходимо указать имя кота. 
• Может быть приведен к текстовой форме вида: “кот: Имя” 
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, 
вызвать мяуканье можно без параметров. 
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных 
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со 
следующей сигнатурой:

Алгоритм: 
Объявляем интерфейс Мяукающее, содержащий единственный метод мяукнуть() без параметров. Создаём класс Кот, который реализует этот интерфейс. В классе Кот объявляем приватное поле имя типа строка и инициализируем его через конструктор. Переопределяем метод toString(), чтобы он возвращал строку вида "кот: Имя". Реализуем метод мяукнуть() из интерфейса так, чтобы при вызове на экран выводилось сообщение "Имя: мяу!".

Создаём класс СчётчикМяуканий, который также реализует интерфейс Мяукающее. В этом классе объявляем два приватных поля: ссылка на объект Кот и целочисленный счётчик, инициализированный нулём. В конструкторе принимаем объект Кота и сохраняем ссылку на него. Реализуем метод мяукнуть() так, чтобы он увеличивал счётчик на единицу, а затем вызывал метод мяукнуть() у сохранённого кота.

Создаём класс Мяуканье со статическим методом, который принимает массив или коллекцию объектов типа Мяукающее. В этом методе в цикле вызываем метод мяукнуть() для каждого переданного объекта.

Для решения основной задачи создаём объект Кота. Затем создаём объект СчётчикМяуканий, передавая в его конструктор созданного кота. Далее вызываем метод класса Мяуканье, передавая ему наш счётчик (который является Мяукающим объектом). После завершения работы метода получаем количество мяуканий из счётчика и выводим его на экран. При этом сам класс Кот остаётся неизменным, как и требуется по условию.

<img width="224" height="115" alt="image" src="https://github.com/user-attachments/assets/7edae49f-2e13-496b-a61f-2daa6d903b2d" />

## Задание 3
## Задача 5
Составить программу, которая удаляет из списка L все элементы с указанным значением.

Алгоритм:
Создаем класс Удаление. Объявляем два поля: список и значение, которое нужно удалить. Создаем метод удаления, если введенный элемент соответствует элементу списка, удаляем его. Создаем метод для ввода числа.

<img width="366" height="185" alt="image" src="https://github.com/user-attachments/assets/c04fe6bf-41a4-4a0a-b0ac-5a6993d619b1" />

## Задание 4
## Задача 2
На городской олимпиаде по информатике участникам было предложено выполнить 3 задания, 
каждое из которых оценивалось по 25-балльной шкале. Известно, что общее количество 
участников первого тура олимпиады не превосходит 250 человек. На вход программы подаются 
сведения о результатах олимпиады. В первой строке вводится количество участников N. Далее 
следуют N строк, имеющих следующий формат: 
<Фамилия><Имя><Баллы> 
Здесь<Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не 
более чем из 15 символов;<Баллы>– строка, содержащая три целых числа, разделенных 
пробелом, соответствующих баллам, полученным участником за каждое задание первого тура. 
При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Примеры входных 
строк:  
Петрова Ольга 25 18 16 
Калиниченко Иван 14 19 15 
Напишите программу, которая будет выводить на экран фамилию и имя участника, набравшего 
максимальное количество баллов. Если среди остальных участников есть ученики, набравшие 
такое же количество баллов, то их фамилии и имена также следует вывести. При этом имена и 
фамилии можно выводить в произвольном порядке. 

Алгоритм:
Сначала определяем структуру данных для хранения информации об участнике. Создаём класс, в котором будут храниться фамилия, имя и три оценки за задания. В этом же классе реализуем метод для вычисления общей суммы баллов участника, просто складывая все три оценки.

В основной программе считываем общее количество участников. Проверяем, что их количество не превышает допустимого значения (250 человек). Затем организуем цикл, в котором построчно считываем данные каждого участника. Каждую строку разбираем на составляющие: первые два слова — это фамилия и имя, следующие три числа — баллы за задания. Создаём объект участника с этими данными и сохраняем его в список.

После того как все данные считаны, находим максимальный общий балл среди всех участников. Для этого проходим по всем сохранённым объектам, вычисляем для каждого сумму баллов и сравниваем с текущим максимумом, обновляя его при необходимости.

Затем выполняем второй проход по списку участников. Для каждого снова вычисляем сумму баллов и сравниваем с найденным максимальным значением. Всех участников, чья сумма совпадает с максимумом, добавляем в отдельный список победителей.


## Задание 5
## Задача 3
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все согласные буквы, 
которые входят ровно в одно слово. 

Алгоритм:
Создаём класс, который будет отвечать за извлечение требуемых согласных букв из текста. Определяем в этом классе константное множество, содержащее все согласные буквы русского алфавита в нижнем регистре (например, «б», «в», «г» и т.д., включая «й», но исключая гласные и мягкий/твёрдый знаки).
В основном методе класса принимаем путь к файлу. Проверяем существование файла и обрабатываем возможные исключения (например, если файл не найден). Читаем всё содержимое файла в одну строку.Приводим весь текст к нижнему регистру, чтобы обеспечить регистронезависимую обработку. Затем очищаем строку от всех символов, не являющихся буквами или пробелами (удаляем знаки препинания, цифры, специальные символы), оставляя только буквы и пробелы для корректного разделения на слова.Разбиваем полученную строку на отдельные слова, используя пробел как разделитель. Получаем массив или список слов.Создаём ассоциативный контейнер (например, хэш-таблицу), где ключом будет согласная буква, а значением — множество индексов слов (или их уникальных идентификаторов), в которых эта буква встречается. Это позволит отслеживать, в скольких разных словах встречается каждая согласная.Проходим циклом по всем словам. Для каждого слова в отдельном внутреннем цикле анализируем каждую его букву. Если текущая буква присутствует в множестве согласных, то обновляем ассоциативный контейнер: для данной согласной буквы добавляем индекс текущего слова в соответствующее множество.После полного обхода текста формируем результат. Создаём пустой список для требуемых согласных. Проходим по всем записям ассоциативного контейнера. Для каждой согласной буквы проверяем размер множества индексов слов: если оно равно 1, значит, эта согласная встречается ровно в одном слове текста. Добавляем такую букву в результирующий список.
Отсортировываем результирующий список букв в алфавитном порядке. Возвращаем или выводим отсортированный список согласных, каждая из которых встречается ровно в одном слове текста.

## Задание 6
## Задача 4
Проверить равенство участка очереди с i-го по j-й элемент (i < j). 

Алгоритм:
Создаем класс Очередь. В нем объявляем поле - очередь. Создаем метод, который проверяет равны ли участки. Принимает начало и конец двух участков. Делаем проверки для участков. Сравниваем элементы.

<img width="320" height="294" alt="image" src="https://github.com/user-attachments/assets/805b2b39-973f-402c-86db-8d56678dec63" />

## Задание 7
## Задача 1
Необходимо написать стрим: 
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с 
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это 
все в ломаную (объект типа Polyline) 
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их: 
1. класс Point: 
• Координата Х: число.   
• Координата Y: число. 
• Может возвращать текстовое представление вида “{X;Y}”. 
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается: 
• Координата начала: Точка 
• Координата конца: Точка 
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}” 
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная 
линия представляет собой набор следующих характеристик:   
• Имеет массив Точек, через которые линия проходит. 
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это 
результат приведения к строке Точки с номером N

Алгоритм:
Создаём класс Point с полями x и y типа double (или int, в зависимости от требований). Добавляем конструктор, геттеры для обоих полей и сеттер только для y (так как x остаётся неизменным после создания). Переопределяем методы equals() и hashCode() для корректного сравнения точек по обеим координатам. Также переопределяем toString() для представления точки в формате "{X;Y}".
Создаём класс Polyline для представления ломаной линии. Добавляем поле — список (или массив) точек. Реализуем метод addPoint(Point p) для добавления точек и переопределяем toString() для вывода в формате "Линия [Т1,T2,…,TN]", где каждая точка выводится через свой toString().
Создаём объект Polyline и добавляем в него все точки из обработанного списка. Получаем готовую ломаную линию, соответствующую требованиям задачи.

<img width="444" height="138" alt="image" src="https://github.com/user-attachments/assets/fdbd0f76-ed56-48af-8f3f-a37cab7b701e" />
